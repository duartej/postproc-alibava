#!/usr/bin/env python
"""
Extract the list of alibava raw data files from a parent folder.
The folder should contain subdirectories with the name
of the involved sensors, and the file names follows a pre-defined
naming convention.
"""
__author__ = "Jordi Duarte-Campderros"
__credits__ = ["Jordi Duarte-Campderros"]
__version__ = "v0.1"
__maintainer__ = "Jordi Duarte-Campderros"
__email__ = "jorge.duarte.campderros@cern.ch"
__status__ = "Development"

def list_raw_files(parent_folder,verbose):
    """Extract the list of alibava raw data files from a parent folder.
    The folder should contain subdirectories with the name
    of the involved sensors, and the file names follows a pre-defined
    naming convention.

    Parameters
    ----------
    parent_folder: str
        the path under where the sensors subdirectories must be localized
    verbose: bool
        whether or not to dump out more information whenever a file has
        been not included
    """
    import alibavaSkifftools.SPS2017TB_metadata as tb2017
    import glob
    import os

    # -- Check the sensors paths are there
    sensor_paths = [ os.path.join(parent_folder,s) for s in tb2017.sensor_names ]
    if False in filter(lambda abspath: os.path.isdir(abspath), sensor_paths):
        raise IOError("Invalid parent folder structure at '{0:s}', "\
            "missing sensors direcotories ".format(parent_folder))
    # -- 
    ###if sensor not in tb2017.sensor_names:
    ###    raise RuntimeError("Not a valid sensor name '{0}'".format(sensor))
    # -- Descend over each directory and fill a dictionary with 
    #    filename_parser instances
    sensor_files = {}
    failed = []
    for sensor in tb2017.sensor_names:
        sensor_files[sensor] = []
        beam_files =[]
        ped_cal = []
        for fname in glob.glob(os.path.join(os.path.join(parent_folder,sensor),"*.dat")):
            try:
                _prv = tb2017.filename_parser(fname)
            except RuntimeError:
                # The file-name format is not understood
                if fname.find("RunN") == -1:
                    print "Just ignoring '{0}'".format(fname) 
                continue
            if _prv.is_beam:
                beam_files.append(_prv)
            else:
                ped_cal.append(_prv)
        # After split between beam and auxiliary runs, associate them
        for _fb in beam_files:
            try:
                sensor_files[sensor].append(tb2017.associated_filenames(_fb,ped_cal))
            except IOError:
                # No pedestals nor calibration, skip this file
                continue
            except RuntimeError:
                # Store if verbose
                if verbose:
                    failed.append( (_fb,ped_cal) )
                continue
            ped_cal.remove(sensor_files[sensor][-1].pedestal_instance)
            ped_cal.remove(sensor_files[sensor][-1].calibration_instance)
    for sname,flist in sensor_files.iteritems():
        print "\033[1;34mSENSOR:\033[1;m \033[1;20m{0}\033[1;m".format(sname)
        for af in flist:
            print af
    if verbose:
        print "\033[1;33mVERBOSE: Sensors and runs with incomplete/inconsistent files\033[1;m"
        for (finst,pedcallist) in failed:
            pedflen=len(filter(lambda x: x.is_pedestal,pedcallist))
            calflen=len(filter(lambda x: x.is_calibration,pedcallist))
            print "{0}, run: {1}, [# ped. files:{2}, "\
                    "# cal. files:{3}]".format(
                            finst.sensor_name,finst.run_number,
                            pedflen,calflen)

def create_steering_file(step_name,**args):
    """Create the steering file for the given step. The steering
    file will be created in the working directory. If no extra
    arguments are provided, the default will be applied

    Parameters
    ----------
    step_name: str
        the name of the step. Must correspond to a concrete class 
        of alibavaSkifftools.steering_processing.marlin_step

    ALIBAVA_INPUT_FILENAME: str, optional
        The input file name of the RAW alibava file

    See also
    --------
    alibavaSkifftools.steering_processing.marlin_step and
    their concrete classes, to get a list of valid and needed 
    template arguments
    """
    from alibavaSkifftools import steering_processing

    # create the marlin step instance
    step = steering_processing.create_marlin_step(step_name)
    # And create the steering file
    step.publish_steering_file(**args)


if __name__ == '__main__':
    from argparse import ArgumentParser,Action
    from alibavaSkifftools.SPS2017TB_metadata import eospath,sensor_names
    from alibavaSkifftools.steering_processing import _ARGUMENTS as template_args

    # Helper class to allow list sensor names (without introducing
    # the positional arguments
    class SensorNamesAction(Action):
        def __init__(self,option_strings,dest,default=False,required=False,help=None):
            super(SensorNamesAction, self).__init__(
                    option_strings=option_strings,
                    dest=dest,
                    nargs=0,
                    const=True,
                    default=default,
                    required=required,
                    help=help)

        def __call__(self, parser, namespace, values, option_string=None):
            print "\033[1;34mAvailable sensor names:\033[1;m"
            for sensor in sensor_names:
                print " - {0}".format(sensor)
            parser.exit()
    
    # Helper class to allow list steering steps (without introducing
    # the positional arguments
    class StepNamesAction(Action):
        def __init__(self,option_strings,dest,default=False,required=False,help=None):
            super(StepNamesAction, self).__init__(
                    option_strings=option_strings,
                    dest=dest,
                    nargs=0,
                    const=True,
                    default=default,
                    required=required,
                    help=help)

        def __call__(self, parser, namespace, values, option_string=None):
            from alibavaSkifftools.steering_processing import available_steps as _steps
            print "\033[1;34mAvailable steps:\033[1;m"
            for step in _steps:
                print " - \033[1;29m{0}\033[1;m: {1}".format(step.__name__,step.get_description())
            parser.exit()
    
    mesdsc="A suite of tools to deal with the ALIBAVA (and EUTelescope)"
    mesdsc+=" data output"
    parser = ArgumentParser(prog='open_sesame',description=mesdsc)
    
    # Sub-command parsers
    subparsers = parser.add_subparsers(title='subcommands',
            description='valid subcommands', 
            help='additional help')
    
    # -- Subparser: list data sensor, test beam data associated to their
    #               respective pedestal and calibration files 
    usage_ld  = "Extract the list of alibava raw data files from a parent folder. "
    usage_ld += "The folder should contain subdirectories with the name of the"
    usage_ld += " involved sensors; and the file names follow a pre-defined naming "
    usage_ld += "convention."
    
    ld_parser = subparsers.add_parser("list_files",description=usage_ld)
    ld_parser.add_argument('parent_folder',help="The parent folder to start"\
            " to search down [Default: see SPS2017TB_metadata.eospath]")
    ld_parser.add_argument('-p','--print-available-sensors',dest="available_sensors",\
            action=SensorNamesAction,help='Just print the available'\
            ' sensor names')
    ld_parser.add_argument('-v',dest="verbose",action='store_true',help="Show the list of ignored run numbers"\
            " because of any problem")
    ld_parser.set_defaults(which='list_files',parent_folder=eospath,ignore_runs=[])
    
    # -- Subparser: steering file creator for the ALIBAVA/TELESCOPE data 
    #               reconstruction
    usage_st  = "Build the needed steering files to run a given step of the marlin"
    usage_st += " framework reconstruction for the ALIBAVA or TELESCOPE data. Note"
    usage_st += " that the steering file is created in the working directory."
    usage_st += " All the available options but the `--print-availble-steps` are"
    usage_st += " directly related with the relevant steering file (see the"
    usage_st += " steering files under `steering_files` directory "

    st_parser = subparsers.add_parser("steering",description=usage_st)
    st_parser.add_argument('step',help="The step name to create the steering file"\
            " [See `--print-available-steps` option] ")
    st_parser.add_argument('--alibava-input-filename',dest="ALIBAVA_INPUT_FILENAME",action='store',\
            help=template_args['ALIBAVA_INPUT_FILENAME'])
    st_parser.add_argument('--input-filename',dest="INPUT_FILENAMES",action='store',\
            help=template_args['INPUT_FILENAMES'])
    st_parser.add_argument('--run-number',dest="RUN_NUMBER",action='store',\
            help=template_args['RUN_NUMBER'])
    st_parser.add_argument('--root-filename',dest="ROOT_FILENAME",action='store',\
            help=template_args['ROOT_FILENAME'])
    st_parser.add_argument('--gear-file',dest="GEAR_FILE",action='store',\
            help=template_args['GEAR_FILE'])
    st_parser.add_argument('--output-filename',dest="OUTPUT_FILENAME",action='store',\
            help=template_args['OUTPUT_FILENAME'])
    st_parser.add_argument('--pedestal-output-filename',dest="PEDESTAL_OUTPUT_FILENAME",action='store',\
            help=template_args['PEDESTAL_OUTPUT_FILENAME'])
    st_parser.add_argument('--pedestal-input-filename',dest="PEDESTAL_INPUT_FILENAME",action='store',\
            help=template_args['PEDESTAL_INPUT_FILENAME']+" (Related with --pedestal-ouput-filename)")
    st_parser.add_argument('--histo-xmax',dest="MAXADC",action='store',\
            help=template_args['MAXADC'])
    st_parser.add_argument('--histo-xmin',dest="MINADC",action='store',\
            help=template_args['MINADC'])
    st_parser.add_argument('--histo-nbins',dest="NBINS",action='store',\
            help=template_args['NBINS'])
    st_parser.add_argument('--calibration-output-filename',dest="CALIBRATION_OUTPUT_FILENAME",action='store',\
            help=template_args['CALIBRATION_OUTPUT_FILENAME'])
    st_parser.add_argument('--timecut-min',dest="TIMECUT_MIN",action='store',\
            help=template_args['TIMECUT_MIN'])
    st_parser.add_argument('--timecut-max',dest="TIMECUT_MAX",action='store',\
            help=template_args['TIMECUT_MAX'])
    st_parser.add_argument('--cmmdcut-min',dest="CMMDCUT_MIN",action='store',\
            help=template_args['CMMDCUT_MIN'])
    st_parser.add_argument('--cmmdcut-max',dest="CMMDCUT_MAX",action='store',\
            help=template_args['CMMDCUT_MAX'])
    st_parser.add_argument('--snrcut-seed',dest="SNRCUT_SEED",action='store',\
            help=template_args['SNRCUT_SEED'])
    st_parser.add_argument('--snrcut-neighbour',dest="SNRCUT_NGB",action='store',\
            help=template_args['SNRCUT_NGB'])
    st_parser.add_argument('--signal-polarity',dest="SIGNAL_POLARITY",action='store',\
            help=template_args['SIGNAL_POLARITY'])
    st_parser.add_argument('--sensor-id-starts-at',dest="SENSORID_STARTS",action='store',\
            help=template_args['SENSORID_STARTS'])
    st_parser.add_argument('-p','--print-available-steps',dest="available_steps",\
            action=StepNamesAction,help='Just print the available step names')
    st_parser.set_defaults(which='steering',ignore_runs=[])

    args = parser.parse_args()
    
    if args.which == 'list_files':
        list_raw_files(args.parent_folder,args.verbose)
    elif args.which == 'steering':
        valid_args = template_args.keys()
        # Get the list of arguments related with the steering file template
        # which are filled
        the_args = dict(filter(lambda (k,v): k in valid_args and v is not None,args.__dict__.iteritems()))
        # arguments in the template steering files
        create_steering_file(args.step,**the_args)

